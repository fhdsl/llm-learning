<!-- Generated by SpecStory -->

# Adding comments to R code for clarity (2025-05-16 14:42:02)

_**User**_

Add comments to my code in coexpressionModules.R

---

_**Assistant**_

I'll help add descriptive comments to the code focused on the section you're viewing. Here's the commented version:

````r
# Print the current marker being used for sorting
print(sortMarker)

# Sort the data table by the selected marker
setkeyv(data, sortMarker)

# Store marker list order (potential TODO: implement similarity-based ordering)
markerOrder <- markerList

# Create a black to white color gradient with 60 steps for the heatmap
colPanel <- gplots::colorpanel(60, low="black", high="white")

# Generate heatmap visualization:
# 1. Filter data for selected cells and donor
# 2. Convert to matrix and transpose for proper orientation
# 3. Apply color palette
image(t(as.matrix(data[cell %in% cells() & sample==donorID, markerList, with=FALSE])),
      col = colPanel, axes=FALSE)

# Add marker labels to x-axis, rotated 45 degrees for readability
axis(side=1, labels=markerList, 
     at=0:(length(markerList)-1)/(length(markerList)-1), las=3)

# Add title showing donor ID and number of cells included
title(paste0(donorID, " (n=", length(cells()), ")"))

# Dynamic height calculation for the plot
}, height= function(x){
    # Calculate plot size based on number of cells (1 row per 8 cells + base height)
    plotSize <- floor(length(cells())/8)+200
    
    # Ensure minimum plot height of 300 pixels
    if(plotSize < 300){
      plotSize <- 300
    }
    return(plotSize)
})
````

For the full file context, I can also suggest comments for the UI and main function components if you'd like. Let me know if you want me to continue with those sections.

---

_**User**_

Yes, please continue with these sections

---

_**Assistant**_

I'll add comprehensive comments for the entire file. Here's the fully commented version:

````r
#' Create UI components for coexpression analysis visualization
#'
#' @param id Unique identifier for the Shiny module namespace
#' @param subjectIDList List of available donor/subject IDs
#' @param markerList List of markers available for analysis
#'
#' @return A Shiny UI definition for the coexpression plot controls
#' @export
#'
#' @examples
coexpressionPlotUI <- function(id, subjectIDList, markerList){
  # Create a namespace function using the provided id for Shiny module
  ns <- NS(id)

  # Create UI elements for user interaction
  tagList(
    # Dropdown for donor selection
    selectInput(ns("donorIdHeatmap"), "Select Donor", choices= subjectIDList,
                selected=subjectIDList[1]),
    # Dropdown for marker selection
    selectInput(ns("sortMarkerHeatmap"), "Select Marker To Sort By",
                choices=markerList, selected=markerList[1]),
    # Slider for filtering marker values
    sliderInput(ns("filterValueHeatmap"), min = -1, max=8, label =
                  "Select Filter Cutoff For Marker", value = 1, step = 0.2)
  )
}

#' Server function for coexpression plot visualization
#'
#' @param input Shiny input object
#' @param output Shiny output object
#' @param session Shiny session object
#' @param data Data table containing marker expression data
#' @param markerList List of markers to display
#'
#' @return None (creates reactive plots)
#' @export
coexpressionPlot <- function(input, output, session, data, markerList){
  # Generate distribution plot for selected marker
  output$miniHistogram <- renderPlot({
    # Default to first sample if none selected
    if(is.null(input$donorIdHeatmap)){
      donorID <- data$sample[1]
    } else{ donorID <- input$donorIdHeatmap}

    # Default to first marker if none selected
    if(is.null(input$sortMarkerHeatmap)){
      sortMarker <- as.character(markerList[1])
    } else {
      sortMarker <- as.character(input$sortMarkerHeatmap)
    }

    # Create histogram of marker expression for selected donor
    hist(data[sample == donorID, get(sortMarker)], 
         main = paste0(sortMarker, " - ", donorID),
         xlab = sortMarker, ylab=NULL, breaks = 30)
  })

  # Reactive value for currently selected marker
  marker <- reactive({
    if(is.null(input$sortMarkerHeatmap)){ sortMarker <- markerList[1]}
    else{sortMarker <- input$sortMarkerHeatmap}
    sortMarker
  })

  # Update slider range based on marker expression range
  observe({
    # Calculate range for all markers excluding first two columns (metadata)
    limits <- apply(data[,-c(1:2)], 2, range)
    
    # Get range for selected marker
    lims <- limits[,marker()]
    print(lims)
    print(marker())
    
    # Update slider input with marker-specific range
    updateSliderInput(session, inputId = "filterValueHeatmap",
                      min=signif(lims[1],digits=3), max = signif(lims[2], digits=3))
  })

  # Reactive expression to filter cells based on marker expression
  cells <- reactive({
    # Get current donor ID
    if(is.null(input$donorIdHeatmap)){
      donorID <- data$sample[1]
    } else{ donorID <- input$donorIdHeatmap}

    # Get current marker
    if(is.null(input$sortMarkerHeatmap)){
      sortMarker <- as.character(markerList[1])
    } else {
      sortMarker <- as.character(input$sortMarkerHeatmap)
    }

    # Get current filter value
    if(is.null(input$filterValueHeatmap)){
      filtValue <- 1
    }else{
      filtValue <- input$filterValueHeatmap
    }

    print(filtValue)

    # Filter cells based on marker expression threshold
    cells <- data[sample == donorID & get(sortMarker) > filtValue, cell]
    cells
  })

  # Generate main heatmap visualization
  output$maitHeatmap <- renderPlot({
    # Get current donor ID and marker
    if(is.null(input$donorIdHeatmap)){
      donorID <- data$sample[1]
    } else{ donorID <- input$donorIdHeatmap}

    if(is.null(input$sortMarkerHeatmap)){
      sortMarker <- as.character(markerList[1])
    } else {
      sortMarker <- as.character(input$sortMarkerHeatmap)
    }

    print(sortMarker)

    # Sort data by selected marker
    setkeyv(data, sortMarker)
    markerOrder <- markerList

    # Create black to white color gradient
    colPanel <- gplots::colorpanel(60, low="black", high="white")

    # Generate heatmap
    image(t(as.matrix(data[cell %in% cells() & sample==donorID, markerList, with=FALSE])),
          col = colPanel, axes=FALSE)
    # Add marker labels
    axis(side=1, labels=markerList, 
         at=0:(length(markerList)-1)/(length(markerList)-1), las=3)
    # Add title with donor ID and cell count
    title(paste0(donorID, " (n=", length(cells()), ")"))

  }, height= function(x){
    # Dynamic height calculation based on cell count
    plotSize <- floor(length(cells())/8)+200
    if(plotSize < 300){
      plotSize <- 300
    }
    return(plotSize)
  })
}
````

The comments now provide clear documentation for:
- Function purpose and parameters
- UI component structure
- Reactive expressions and their purpose
- Data filtering logic
- Plot generation and customization
- Dynamic sizing calculations

Each major code section is 

---

